<!DOCTYPE html>
<html>
<head>
<title>Level 2b</title>
<script src="script.js"></script>
<link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>LEVEL 2b</h1>
    <h3>Merge Sort</h3>
    <h4>Read the tutorial first if you are not confident in this topic and then solve this level.</h4>
    <pre>
        1) First try to sort an array using merge sort:
          <a href="https://practice.geeksforgeeks.org/problems/quick-sort/1">Click here to go to online editor</a>
    </pre>
    <button onclick="ShowDiv1()" width="100" height="30">SHOW</button>
    <button onclick="HideDiv1()" width="100" height="30">HIDE</button>
    <div id="dropdown1" style="display:none">
        <pre>
            Purpose of this question to make sure you know how to write mergesort algorithm.</pre>
    </div>
    <pre>
        2) In a modified merge sort, the input array is splitted at a position one-third of the length(N) of the array. Which of the following 
        is the tightest upper bound on time complexity of this modified Merge Sort.
        
        A)N(logN base 3)
        B)N(logN base 2/3)
        C)N(logN base 1/3)
        D)N(logN base 3/2)
    </pre>
    <button onclick="ShowDiv2()" width="100" height="30">SHOW</button>
    <button onclick="HideDiv2()" width="100" height="30">HIDE</button>
    <div id="dropdown2" style="display:none">
        <pre>
            Correct answer is D.
            The time complexity is given by: T(N) = T(N/3) + T(2N/3) + N.
            Solving the above recurrence relation gives, T(N) = N(logN base 3/2)
        </pre>
    </div>
    <pre>
        3) A list of n string, each of length n, is sorted into lexicographic order using the merge-sort algorithm. The worst case running time 
        of this computation is
        
        A)O(n log n)
        B)O(n<sup>2</sup> log n)
        C)O(n<sup>2</sup> + log n)
        D)O(n<sup>2</sup>)
    </pre>
    <button onclick="ShowDiv3()" width="100" height="30">SHOW</button>
    <button onclick="HideDiv3()" width="100" height="30">HIDE</button>
    <div id="dropdown3" style="display:none">
        <pre>
            Option B is correct.
            The recurrence tree for merge sort will have height Log(n). And O(n^2) work will be done at each level of the recurrence tree
            (Each level involves n comparisons and a comparison takes O(n) time in worst case). So time complexity of this Merge Sort will be O(n<sup>2</sup> log n).
        </pre>
    </div>
    <pre>
        4) Of the following sorting algorithms, which has a running time that is least dependent on the initial ordering of the input?
        
        A)Merge Sort
        B)Insertion Sort
        C)Selection Sort
        D)Quick Sort
    </pre>
    <button onclick="ShowDiv4()" width="100" height="30">SHOW</button>
    <button onclick="HideDiv4()" width="100" height="30">HIDE</button>
    <div id="dropdown4" style="display:none">
        <pre>
            Option (A) is correct. This question was given to tell you that merge sort always happens whether array is sorted or not.
            In Insertion sort if the array is already sorted then it takes O(n) and if it is reverse sorted then it takes O(n2) to sort the array. 
            In Quick sort, if the array is already sorted or if it is reverse sorted then it takes O(n2).The best and worst case performance of 
            Selection is O(n2) only. But if the array is already sorted then less swaps take place. In merge sort, time complexity is O(nlogn) for 
            all the cases and performance is affected least on the the order of input sequence.
        </pre>
    </div><br><br><br>
    <a href="tutorial2b.html">TUTORIAL FOR LEVEL 2b</a><br><br>
    <a href="level3.html">GO TO NEXT LEVEL(Only after completing this level)</a>
</body>
</html>