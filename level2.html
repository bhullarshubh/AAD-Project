<!DOCTYPE html>
<html>
<head>
<title>Level 2</title>
<script src="script.js"></script>
<link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>LEVEL 2</h1>
    <h3>Divide and Conquer Algorithms</h3>
    <h4>Read the tutorial first if you are not confident in this topic and then solve this level.</h4>
    <pre>
        1) Consider the problem of computing min-max in an unsorted array where min and max are minimum and maximum elements of array. Algorithm A1
        can compute min-max in a1 comparisons without divide and conquer. Algorithm A2 can compute min-max in a2 comparisons by scanning the
        array linearly. What could be the relation between a1 and a2 considering the worst case scenarios?

        A)a1 < a2
        B)a1 > a2
        C)a1 = a2
        D)Depends upon input.
    </pre>
    <button onclick="ShowDiv1()" width="100" height="30">SHOW</button>
    <button onclick="HideDiv1()" width="100" height="30">HIDE</button>
    <div id="dropdown1" style="display:none">
        <pre>
            Answer B is the correct answer.
            When Divide and Conquer is used to find the minimum-maximum element in an array, Recurrence relation for the number of comparisons is
            T(n) = 2T(n/2) + 2 where 2 is for comparing the minimums as well the maximums of the left and right subarrays
            On solving, T(n) = 1.5n - 2.
            While doing linear scan, it would take 2*(n-1) comparisons in the worst case to find both minimum as well maximum in one pass.
        </pre>
    </div>
    <pre>
        2) Consider the following C program
        int main() 
        { 
            int x, y, m, n; 
            scanf ("%d %d", &x, &y); 
            /* x > 0 and y > 0 */
            m = x; n = y; 
            while (m != n) 
            { 
                if(m>n) 
                m = m - n; 
                else
                n = n - m; 
            } 
        printf("%d", n); 
        }

        What does the program compute? 
        A)x + y using repeated subtraction
        B)x mod y using repeated subtraction
        C)The greatest common divisor of x and y
        D)The least common multiple of x and y
    </pre>
    <button onclick="ShowDiv2()" width="100" height="30">SHOW</button>
    <button onclick="HideDiv2()" width="100" height="30">HIDE</button>
    <div id="dropdown2" style="display:none">
        <pre>
            Correct answer is C.
            This is an implementation of Euclidâ€™s algorithm to find GCD. This question is given to make you aware with Euclid's algorithm to find 
            GCD. It is also a divide and conquer algorithm.
        </pre>
    </div>
    <pre>
        3) Consider a situation where you don't have function to calculate power and you need to calculate x^n where x can be any number and n is 
        a positive integer. What can be the best possible time complexity of your power function?
        
        A)O(n)
        B)O(nLogn)
        C)O(LogLogn)
        D)O(Logn)
    </pre>
    <button onclick="ShowDiv3()" width="100" height="30">SHOW</button>
    <button onclick="HideDiv3()" width="100" height="30">HIDE</button>
    <div id="dropdown3" style="display:none">
        <pre>
            D is Correct answer.
            By Divide and conquer, time complexity can brought down to O(logn) instead of O(n) where number is multiplied by itself n number of 
            times.
            int power(int x, unsigned int y)
            {
                if (y == 0)
                return 1;
                else if (y%2 == 0)
                     return power(x, y/2)*power(x, y/2);
                else
                return x*power(x, y/2)*power(x, y/2);
            }
            This is how divide and conquer is used in this problem.
        </pre>
    </div><br><br><br>
    <a href="tutorial2.html">TUTORIAL FOR LEVEL 2</a><br><br>
    <a href="level2a.html">GO TO NEXT LEVEL(Only after completing this level)</a>
</body>
</html>